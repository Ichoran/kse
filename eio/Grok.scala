// This file is distributed under the BSD 3-clause license.  See file LICENSE.
// Copyright (c) 2014 Rex Kerr and UCSF

package kse.eio

import scala.annotation.tailrec
import scala.reflect.{ClassTag => Tag}
import kse.flow._

trait Delimiter { @inline def apply(c: Char): Boolean }
object Delimiter {
  val whiteDelimiter = new Delimiter { @inline def apply(c: Char) = c.isWhitespace }
  val spaceDelimiter = new Delimiter { @inline def apply(c: Char) = c == ' ' }
  val tabDelimiter = new Delimiter { @inline def apply(c: Char) = c == '\t' }
  val fileDelimiter = new Delimiter { @inline def apply(c: Char) = c == java.io.File.separatorChar }
  val pathDelimiter = new Delimiter { @inline def apply(c: Char) = c == java.io.File.pathSeparatorChar }
  val lineDelimiter = new Delimiter { @inline def apply(c: Char) = c == '\n' || c == '\r' }
}

  
trait DelimByte { @inline def apply(b: Byte): Boolean }
object DelimByte {
  val whiteDelimByte = new DelimByte { @inline def apply(b: Byte) = (b >= 9 && b <= 13) || (b >= 28 && b <= 32) }
  val spaceDelimByte = new DelimByte { @inline def apply(b: Byte) = b == ' ' }
  val tabDelimByte = new DelimByte { @inline def apply(b: Byte) = b == '\t' }
  val fileDelimByte = new DelimByte { @inline def apply(b: Byte) = b == java.io.File.separatorChar }
  val pathDelimByte = new DelimByte { @inline def apply(b: Byte) = b == java.io.File.pathSeparatorChar }
  val lineDelimByte = new DelimByte { @inline def apply(b: Byte) = b == '\n' || b == '\r' }
}
  

object GrokNumber {
  private[this] val parseErrorNaNBits = java.lang.Double.doubleToRawLongBits(Double.NaN) ^ 1
  val parseErrorNaN = java.lang.Double.longBitsToDouble(parseErrorNaNBits)
  def isParseError(d: Double) = parseErrorNaNBits == java.lang.Double.doubleToRawLongBits(d)
  
  // Need to be careful if reading numbers bigger than these
  val radixLastSafeSigned = Array(
    Long.MaxValue, Long.MaxValue, 4611686018427387903L, 3074457345618258602L, 2305843009213693951L,
    1844674407370955161L, 1537228672809129301L, 1317624576693539401L, 1152921504606846975L, 1024819115206086200L,
    922337203685477580L, 838488366986797800L, 768614336404564650L, 709490156681136600L, 658812288346769700L,
    614891469123651720L, 576460752303423487L, 542551296285575047L, 512409557603043100L, 485440633518672410L,
    461168601842738790L, 439208192231179800L, 419244183493398900L, 401016175515425035L, 384307168202282325L,
    368934881474191032L, 354745078340568300L, 341606371735362066L, 329406144173384850L, 318047311615681924L,
    307445734561825860L, 297528130221121800L, 288230376151711743L, 279496122328932600L, 271275648142787523L,
    263524915338707880L, 256204778801521550L
  )
  
  // If the corresponding bit is set, you can get one more value in a negative number at this radix
  val radixNegLastExtra = 0x100010114L
  
  // Need to be careful if reading unsigned numbers bigger than these
  val radixLastSafeUnsigned = Array(
    Long.MaxValue, Long.MaxValue, 9223372036854775807L, 6148914691236517205L, 4611686018427387903L,
    3689348814741910323L, 3074457345618258602L, 2635249153387078802L, 2305843009213693951L, 2049638230412172401L,
    1844674407370955161L, 1676976733973595601L, 1537228672809129301L, 1418980313362273201L, 1317624576693539401L,
    1229782938247303441L, 1152921504606846975L, 1085102592571150095L, 1024819115206086200L, 970881267037344821L,
    922337203685477580L, 878416384462359600L, 838488366986797800L, 802032351030850070L, 768614336404564650L,
    737869762948382064L, 709490156681136600L, 683212743470724133L, 658812288346769700L, 636094623231363848L,
    614891469123651720L, 595056260442243600L, 576460752303423487L, 558992244657865200L, 542551296285575047L,
    527049830677415760L, 512409557603043100L
  )
  
  // Easier to look up powers of ten than to calculate them
  val smallPowersOfTen = Array(
    1L, 10L, 100L, 1000L, 10000L, 100000L, 1000000L, 10000000L, 100000000L, 1000000000L,
    10000000000L, 100000000000L, 1000000000000L, 10000000000000L, 100000000000000L,
    1000000000000000L, 10000000000000000L, 100000000000000000L, 1000000000000000000L
  )
  
  // These two methods are used to generate the tensToTwos array
  private[this] def bitsFromBigDec(bd: java.math.BigDecimal, n: Int, mc: java.math.MathContext): (Array[Int], Int) = {
    import java.math.{BigDecimal => BD}
    var m = mc.getPrecision
    val half = BD.valueOf(0.5)
    val two = BD.valueOf(2)
    val tiny = BD.valueOf(4e-4)
    val kilo = BD.valueOf(1024)
    var bx = bd
    while (bx.compareTo(half) < 0 && m > 0) {
      if (bx.compareTo(tiny) < 0 && m >= 10) {
        bx = bx.multiply(kilo, mc)
        m -= 10
      }
      else {
        bx = bx.multiply(two, mc)
        m -= 1
      }
    }
    val ignored = mc.getPrecision - m
    val a = new Array[Int]((n+29)/30)
    if (m == 0) return (a, ignored)
    var k = 0
    while (bx.compareTo(BD.ONE) >= 0) {
      if (bx.compareTo(kilo) >= 0) {
        bx = bx.divide(kilo, mc)
        k += 10
      }
      else {
        bx = bx.divide(two, mc)
        k += 1
      }
    }
    m = n
    while (m > 0) {
      m -= 1
      bx = bx.multiply(two)
      if (bx.compareTo(BD.ONE) >= 0) {
        val i = m/30
        val j = m%30
        a(i) |= 1 << j
        bx = bx.subtract(BD.ONE)
      }
    }
    (a, ignored-k)
  }
  private[this] def twosNearTens(places: Int): Array[Int] = {
    import java.math.{MathContext => MC, BigDecimal => BD}
    val lim = math.abs(places)
    val a = new Array[Int](4*(2*lim+1))
    val mc = new MC(2048)
    var i = -lim
    while (i <= lim) {
      val k = if (i < 0) -8*i-4 else 8*i
      val bd = if (i == 0) BD.ONE else new BD(s"1e$i")
      val (x,n) = bitsFromBigDec(bd, 90, mc)
      a(k) = n
      a(k+1) = x(2)
      a(k+2) = x(1)
      a(k+3) = x(0)
      i += 1
    }
    a
  }

  val tensToTwos = Array( // from twosNearTens(360)
    -1, 536870912, 0, 0,
    3, 858993459, 214748364, 858993459, -4, 671088640, 0, 0, 6, 687194767, 386547056, 687194767, -7, 838860800, 0, 0,
    9, 549755813, 953482739, 764504178, -10, 1048576000, 0, 0, 13, 879609302, 237082194, 793709956, -14, 655360000, 0, 0,
    16, 703687441, 833910850, 205471235, -17, 819200000, 0, 0, 19, 562949953, 452380315, 379125353, -20, 1024000000, 0, 0,
    23, 900719925, 509060139, 821348929, -24, 640000000, 0, 0, 26, 720575940, 407248111, 871827508, -27, 800000000, 0, 0,
    29, 576460752, 325798489, 482713642, -30, 1000000000, 0, 0, 33, 922337203, 736025947, 987090192, -34, 625000000, 0, 0,
    36, 737869762, 1018317487, 1004420518, -37, 781250000, 0, 0, 39, 590295810, 385157260, 803536414, -40, 976562500, 0, 0,
    43, 944473296, 616251617, 211916439, -44, 610351562, 536870912, 0, 46, 755578637, 278252928, 1028526611, -47, 762939453, 134217728, 0,
    49, 604462909, 866847437, 608072924, -50, 953674316, 436207616, 0, 53, 967140655, 742710805, 758168313, -54, 596046447, 809500672, 0,
    56, 773712524, 594168644, 606534650, -57, 745058059, 743440384, 0, 59, 618970019, 690083280, 485227720, -60, 931322574, 660865024, 0,
    63, 990352031, 459888154, 346867623, -64, 582076609, 144605184, 0, 66, 792281625, 153162158, 706990828, -67, 727595761, 449191936, 0,
    69, 633825300, 122529726, 995089392, -70, 909494701, 829925376, 0, 73, 1014120480, 196047563, 88904474, -74, 568434188, 652921088, 0,
    76, 811296384, 156838050, 500620308, -77, 710542735, 816151360, 0, 79, 649037107, 340218805, 185747882, -80, 888178419, 751753744, 0,
    83, 1038459371, 759098453, 82448246, -84, 555111512, 335628362, 0, 86, 830767497, 392530397, 710203691, -87, 693889390, 419535452, 536870912,
    89, 664613997, 958269412, 568162953, -90, 867361737, 1061290227, 671088640, 93, 1063382396, 674237600, 909060725, -94, 542101086, 260653208, 285212672,
    96, 850705917, 324641715, 941996945, -97, 677626357, 862687422, 356515840, 99, 680564733, 903958467, 109352461, -100, 847032947, 273052909, 982515712,
    102, 544451787, 78921679, 302230334, -103, 1058791184, 72880681, 422838272, 106, 871122859, 341023051, 698316899, -107, 661744490, 45550425, 935362560,
    109, 696898287, 487566806, 129156790, -110, 827180612, 593808944, 363896832, 112, 557518629, 1034298539, 318073796, -113, 1033975765, 742261180, 454871040,
    116, 892029807, 1010632568, 508918075, -117, 646234853, 598130965, 821165312, 119, 713623846, 379009325, 192386095, -120, 807793566, 1016099163, 221150272,
    122, 570899077, 88459095, 368657241, -123, 1009741958, 733253042, 8002384, 126, 913438523, 356282917, 375103220, -127, 631088724, 189847695, 273436946,
    129, 730750818, 714523063, 514830941, -130, 788860905, 237309619, 73360726, 132, 584600654, 1001115180, 411864753, -133, 986076131, 565072479, 897007276,
    136, 935361047, 957539194, 229486875, -137, 616297582, 218952571, 963282731, 139, 748288838, 336534625, 827834594, -140, 770371977, 810561626, 935667958,
    142, 598631070, 698724430, 232770946, -143, 962964972, 207895665, 632714036, 146, 957809713, 44217264, 372433513, -147, 601853107, 666805702, 1066534912,
    149, 766247770, 464870541, 83198446, -150, 752316384, 565071672, 796297728, 152, 612998216, 371896432, 925552216, -153, 940395480, 706339590, 995372160,
    156, 980797146, 165537562, 1051386816, -157, 587747175, 441462244, 353672144, 159, 784637716, 991423509, 626361088, -160, 734683969, 283392349, 442090180,
    162, 627710173, 578390442, 930585600, -163, 918354961, 622675892, 821048181, 166, 1004336277, 710676343, 844691866, -167, 573971850, 1060261072, 1050026025,
    169, 803469022, 139044345, 461005128, -170, 717464813, 788455429, 238790708, 172, 642775217, 755480570, 798300832, -173, 896831017, 180262918, 566923841,
    176, 1028440348, 349775453, 1062532966, -177, 560519385, 783752964, 85891944, 179, 822752278, 709317092, 850026373, -180, 700649232, 174384837, 107364930,
    182, 658201822, 996950403, 894769463, -183, 875811540, 217981046, 402641619, 186, 1053122916, 736127186, 1002134411, -187, 547382212, 673109065, 1056957380,
    189, 842498333, 374153384, 801707529, -190, 684227765, 841386332, 515890357, 192, 673998666, 728819437, 426617658, -193, 855284707, 246426547, 644862946,
    195, 539198933, 368307185, 126545762, -196, 1069105884, 39597728, 537643227, 199, 862718293, 374543131, 417221584, -200, 668191177, 561619492, 336027017,
    202, 690174634, 729131234, 763273997, -203, 835238971, 970459821, 420033771, 205, 552139707, 798053352, 610619197, -206, 1044048714, 944639320, 793477670,
    209, 883423532, 417891904, 976990716, -210, 652530446, 858835031, 495923543, 212, 706738825, 978558618, 352095843, -213, 815663058, 536672877, 351468973,
    215, 565391060, 782846894, 711173404, -216, 1019578823, 133970184, 707771673, 219, 904625697, 178813207, 493632352, -220, 637236764, 486384549, 442357295,
    222, 723700557, 787295660, 394905881, -223, 796545955, 607980686, 821382075, 225, 578960446, 200339798, 745421435, -226, 995682444, 491540402, 489856682,
    229, 926336713, 964788772, 333680837, -230, 622301527, 844083663, 574595882, 232, 741069371, 127585923, 481693034, -233, 777876909, 786669123, 449809397,
    235, 592855496, 961062197, 1029599521, -236, 972346137, 178030036, 293826290, 239, 948568795, 34460963, 144120681, -240, 607716335, 782357412, 720512343,
    242, 758855036, 27568770, 544793274, -243, 759645419, 709511309, 900640429, 245, 607084028, 881048475, 650582984, -246, 949556774, 618453681, 320494168,
    249, 971334446, 121187372, 181939316, -250, 593472984, 118098094, 871397495, 252, 777067556, 955943356, 1004544912, -253, 741841230, 147622618, 552375957,
    255, 621654045, 550006320, 803635929, -256, 927301537, 721399185, 153599034, 259, 994646472, 880010113, 212075663, -260, 579563461, 48221306, 767088036,
    262, 795717178, 274511360, 1028653990, -263, 724454326, 328712089, 421989133, 265, 636573742, 649105818, 393426462, -266, 905567907, 947761023, 795921873,
    269, 1018517988, 179575850, 199985610, -270, 565979942, 458132911, 900104354, 272, 814814390, 573157409, 804233582, -273, 707474928, 35795227, 856694987,
    275, 651851512, 458525927, 858135230, -276, 884343660, 44744034, 802433278, 279, 1042962419, 948389849, 299274545, -280, 552714787, 564835933, 769956255,
    282, 834369935, 973460244, 239419636, -283, 690893484, 437609461, 157138950, 285, 667495948, 778768195, 406284073, -286, 863616855, 547011826, 464859144,
    289, 1067993517, 1031280747, 864802883, -290, 539760534, 744535575, 558972421, 292, 854394814, 395527868, 691842306, -293, 674700668, 393798557, 430280070,
    295, 683515851, 531170659, 768222210, -296, 843375835, 492248196, 806285544, 298, 546812681, 210188162, 1044074497, -299, 1054219794, 346874789, 1007856930,
    302, 874900289, 980546155, 167280642, -303, 658887371, 485232199, 764128309, 305, 699920231, 999185288, 992817973, -306, 823609214, 338104793, 686724930,
    308, 559936185, 584599866, 364757649, -309, 1029511517, 959501904, 53099795, 312, 895897896, 935359786, 154115508, -313, 643444698, 733906418, 33187372,
    315, 716718317, 533539464, 123292407, -316, 804305873, 380512110, 578355127, 318, 573374653, 1071076665, 742879020, -319, 1005382341, 744075594, 186072997,
    322, 917399446, 425232476, 329612972, -323, 628363963, 599264974, 384731079, 325, 733919557, 125437616, 263690378, -326, 785454954, 480645761, 1017784761,
    328, 587135645, 744595187, 425700667, -329, 981818693, 63936290, 466924583, 332, 939417033, 117610475, 895869432, -333, 613636683, 174177909, 560263320,
    335, 751533626, 523585110, 287198816, -336, 767045853, 1023028754, 968764606, 338, 601226901, 204119723, 444507418, -339, 958807317, 473479575, 674084846,
    342, 961963041, 970836651, 925960233, -343, 599254573, 430142462, 823956213, 345, 769570433, 561920956, 740768186, -346, 749068216, 806113534, 493074354,
    348, 615656346, 879033494, 1022111279, -349, 936335270, 1007641918, 79472030, 352, 985050154, 976956862, 346887857, -353, 585209544, 361340742, 854976387,
    355, 788040123, 996313854, 707007015, -356, 731511930, 451675928, 531849572, 358, 630432099, 152805989, 350857247, -359, 914389913, 27723998, 664811965,
    362, 1008691358, 673986312, 561371596, -363, 571493695, 688416139, 147072022, 365, 806953086, 968685779, 663845642, -366, 714367119, 592084717, 989146395,
    368, 645562469, 560200258, 960573243, -369, 892958899, 471670441, 431126626, 372, 1032899951, 252075319, 892672094, -373, 558099312, 160576297, 940542781,
    375, 826319960, 1060653715, 69892581, -376, 697624140, 200720372, 370372109, 378, 661055968, 848522972, 55914065, -379, 872030175, 250900465, 462965136,
    382, 1057689550, 69146566, 518959233, -383, 545018859, 559465974, 960441850, 385, 846151640, 55317253, 200419022, -386, 681273574, 430897012, 663681400,
    388, 676921312, 44253802, 589831947, -389, 851591968, 1750353, 829601750, 391, 541537049, 679648136, 471865557, -392, 1064489960, 2187942, 231695820,
    395, 866459279, 443191923, 969733257, -396, 665306225, 1367463, 950116255, 398, 693167423, 569301903, 990534970, -399, 831632781, 270144785, 919209863,
    401, 554533938, 884938252, 792427976, -402, 1039540976, 606116438, 343705961, 405, 887254302, 127411015, 623639668, -406, 649713110, 378822773, 1020122594,
    408, 709803441, 746173906, 928408464, -409, 812141387, 1010399379, 469846874, 411, 567842753, 382190760, 742726771, -412, 1015176734, 994563768, 318873137,
    415, 908548405, 396756852, 329369374, -416, 634485459, 353166899, 199295710, 418, 726838724, 317405481, 907740594, -419, 793106824, 173023167, 1054426006,
    421, 581470979, 468672750, 296695745, -422, 991383530, 216278959, 1049597052, 425, 930353567, 105631306, 45216463, -426, 619614706, 403609805, 1058651341,
    428, 744282853, 728750139, 250921535, -429, 774518382, 1041383169, 518007809, 431, 595426282, 1012496840, 1059730687, -432, 968147978, 764858049, 915945217,
    435, 952682052, 761001486, 407078911, -436, 605092486, 746471737, 169812576, 438, 762145642, 179304459, 540411494, -439, 756365608, 396218759, 480701177,
    441, 609716513, 787688662, 2832465, -442, 945457010, 495273449, 332441015, 445, 975546421, 1045553494, 434028674, -446, 590910631, 577981361, 878864274,
    448, 780437137, 621694430, 776719669, -449, 738638289, 454041246, 293273975, 451, 624349710, 67858814, 1050872465, -452, 923297861, 835987013, 903463381,
    455, 998959536, 108574103, 1037150849, -456, 577061163, 656709611, 698882341, 458, 799167628, 945852742, 400223950, -459, 721326454, 552451558, 605167470,
    461, 639334103, 112437099, 534927525, -462, 901658068, 153693536, 219588426, 465, 1022934564, 1038892818, 426387310, -466, 563536292, 632929372, 137242766,
    468, 818347651, 1045862619, 555858213, -469, 704420365, 791161715, 171553457, 471, 654678121, 621941730, 874183300, -472, 880525457, 183645775, 1019748190,
    475, 1047484994, 565610039, 754448185, -476, 550328410, 785867249, 1039995802, 478, 837987995, 667236396, 603558548, -479, 687910513, 445463150, 494688385,
    481, 670390396, 533789117, 268098474, -482, 859888141, 825264394, 81489570, 485, 1072624634, 424565857, 1073202653, -486, 537430088, 650007974, 319366437,
    488, 858099707, 554401051, 214317028, -489, 671787610, 812509967, 936078958, 491, 686479766, 14024111, 386201987, -492, 839734513, 478766547, 901663242,
    494, 549183812, 870212748, 308961589, -495, 1049668141, 866893640, 858643596, 498, 878694100, 533346938, 64841814, -499, 656042588, 676026253, 536652248,
    501, 702955280, 426677550, 481370180, -502, 820053235, 845032816, 939250766, 504, 562364224, 341342040, 385096144, -505, 1025066544, 787855565, 100321633,
    508, 899782758, 975643994, 186657101, -509, 640666590, 492409728, 196918748, 511, 719826207, 136270100, 1008319140, -512, 800833238, 78641248, 246148436,
    514, 575860965, 753261175, 162410218, -515, 1001041547, 635172472, 307685545, 518, 921377545, 131476056, 259856349, -519, 625650967, 262765067, 192303465,
    521, 737102036, 105180844, 1066878538, -522, 782063709, 60020877, 1045685700, 524, 589681628, 943138135, 209257736, -525, 977579636, 343461553, 501800757,
    528, 943490606, 220530827, 549560743, -529, 610987272, 751534382, 984714113, 531, 754792484, 1035418121, 224900229, -532, 763734090, 939417978, 694021729,
    534, 603833987, 1043082861, 824165278, -535, 954667613, 637401561, 330656250, 538, 966134380, 809939119, 674419350, -539, 596667258, 532593703, 877748796,
    541, 772907504, 647951295, 754283845, -542, 745834073, 128871217, 828750539, 544, 618326003, 733109401, 388678711, -545, 932292591, 429524478, 230631806,
    548, 989321605, 958226677, 407137573, -549, 582682869, 671105982, 949451246, 551, 791457284, 766581341, 969955153, -552, 728353587, 33576110, 649943146,
    554, 633165827, 828013438, 346467392, -555, 910441983, 847276506, 275558021, 558, 1013065324, 465828042, 124851099, -559, 569026239, 932201000, 440659219,
    561, 810452259, 587410798, 529377608, -562, 711282799, 896815794, 550824024, 564, 648361807, 684677003, 638250451, -565, 889103499, 852584287, 151659118,
    568, 1037378892, 236489746, 591703993, -569, 555689687, 398647451, 497440132, 571, 829903113, 833436891, 688111559, -572, 694612109, 229873858, 353364710,
    574, 663922491, 22504418, 979985977, -575, 868265136, 555777778, 978576799, 578, 1062275985, 680252164, 708984104, -579, 542665710, 347361111, 880045955,
    581, 849820788, 544201731, 781935648, -582, 678332137, 971072301, 831621988, 584, 679856630, 864858114, 1055045248, -585, 847915172, 408534009, 234221117,
    587, 543885304, 691886491, 1058784563, -588, 1059893965, 510667511, 561211853, 591, 870216487, 462773292, 835061842, -592, 662433728, 453384922, 753410592,
    594, 696173189, 1014463728, 668049473, -595, 828042160, 566731153, 404892328, 597, 556938551, 1026319347, 749187943, -598, 1035052700, 708413941, 774550866,
    601, 891101683, 138872402, 769203980, -602, 646907937, 979629625, 618312019, 604, 712881346, 540594651, 830111549, -605, 808634922, 419230663, 1041325480,
    607, 570305077, 217727356, 664089239, -608, 1010793652, 1060909241, 1033221394, 611, 912488123, 563112135, 418297688, -612, 631746033, 126197364, 243110187,
    614, 729990498, 879986437, 978883245, -615, 789682541, 426182161, 303887734, 617, 583992399, 59744055, 997854961, -618, 987103176, 801163157, 648295124,
    621, 934387838, 525087219, 93329384, -622, 616939485, 500726973, 539402180, 624, 747510270, 849566504, 933656966, -625, 771174356, 894344172, 942688181,
    627, 598008216, 679653203, 961673937, -628, 963967946, 44188392, 104618403, 631, 956813146, 657948396, 679684841, -632, 602479966, 296053201, 65386501,
    634, 765450517, 311610352, 543747873, -635, 753099957, 906937413, 350168583, 637, 612360413, 893533376, 434998298, -638, 941374947, 328365398, 706146185,
    641, 979776662, 141163213, 481248912, -642, 588359342, 71010646, 172905909, 644, 783821329, 757175665, 170250765, -645, 735449177, 625634219, 753003299,
    647, 627057063, 820488896, 995194071, -648, 919311471, 1050478230, 672818668, 651, 1003291302, 24292046, 303820325, -652, 574569669, 1059202078, 152076211,
    654, 802633041, 663678731, 457804625, -655, 718212087, 518696229, 726966176, 657, 642106433, 316194620, 366243700, -658, 897765109, 379934831, 103401352,
    661, 1027370293, 291163027, 800738285, -662, 561103193, 371676997, 467279029, 664, 821896234, 662427151, 855338993, -665, 701378991, 733031702, 852534242,
    667, 657516987, 744690086, 254774464, -668, 876723739, 647854172, 528796891, 671, 1052027180, 332510678, 837135873, -672, 547952337, 270691129, 867368969,
    674, 841621744, 266008543, 25463604, -675, 684940421, 606799368, 278904843, 677, 673297395, 427555199, 235119248, -678, 856175526, 1026934666, 348631054,
    680, 538637916, 342044159, 402843763, -681, 1070219408, 746797420, 972659729, 684, 861820666, 117773925, 429801656, -685, 668887130, 466748388, 71041419,
    687, 689456532, 953212599, 558589690, -688, 836108913, 46564573, 88801773, 690, 551565226, 333073350, 17375022, -691, 1045136141, 326641172, 379437673,
    694, 882504362, 103420630, 457296765, -695, 653210088, 338368460, 774019457, 697, 706003489, 726981598, 795334142, -698, 816512610, 422960575, 967524322,
    700, 564802791, 796333643, 851015678, -701, 1020640762, 1065571631, 940969946, 704, 903684466, 844637100, 502631626, -705, 637900476, 934417725, 990759400,
    707, 722947573, 460961315, 616853665, -708, 797375596, 94280333, 433142883, 710, 578358058, 798265782, 63986203, -711, 996719495, 117850416, 809864059,
    714, 925372893, 1062476886, 531874654, -715, 622949684, 476309694, 506165037, 717, 740298315, 205736414, 854996453, -718, 778687105, 595387118, 95835384,
    720, 592238652, 164589131, 898745527, -721, 973358881, 1012669353, 656665142, 724, 947581843, 478090975, 793747749, -725, 608349301, 230265162, 7762530,
    727, 758065474, 811969510, 205501469, -728, 760436626, 556266908, 546574074, 730, 606452379, 864323972, 1023394635, -731, 950545783, 158462723, 683217593,
    734, 970323807, 738673262, 348941227, -735, 594091114, 501692386, 292793267, 737, 776259046, 161441880, 279152981, -738, 742613893, 90244570, 902862496,
    740, 621007236, 988146963, 438070750, -741, 928267366, 381241169, 591707209, 744, 993611579, 77796587, 915661565, -745, 580167103, 1043582098, 1040905645,
    747, 794889263, 276985635, 88284157, -748, 725208879, 1036042167, 764261145, 750, 635911410, 651085237, 714872420, -751, 906511099, 1026617253, 686890975,
    754, 1017458256, 1041736380, 284802413, -755, 566569437, 507418055, 563524587, 757, 813966605, 618640739, 442590295, -758, 708211796, 902708025, 435970278,
    760, 651173284, 494912591, 568820601, -761, 885264746, 54643207, 813398304, 764, 1041877255, 147615052, 51119503, -765, 553290466, 302587460, 911027124,
    767, 833501804, 118092041, 685140697, -768, 691613082, 915105238, 65042081, 770, 666801443, 309221998, 118615828, -771, 864516353, 607010635, 618173513,
    774, 1066882309, 280006832, 189785324, -775, 540322720, 1050470287, 252140717, 777, 853505847, 438753830, 581324989, -778, 675403401, 239346035, 46740441,
    780, 682804677, 995248158, 894556721, -781, 844254251, 567617999, 863731919, 783, 546243742, 366701797, 500897012, -784, 1055317814, 441087043, 811229443,
    787, 873989987, 801471240, 801435219, -788, 659573634, 7243946, 372800674, 790, 699191990, 211680262, 1070644905, -791, 824467042, 545925844, 1002871754,
    793, 559353592, 169344210, 427019194, -794, 1030583803, 145536394, 179847869, 797, 894965747, 485699101, 468482346, -798, 644114876, 1030484342, 380840374,
    800, 715972597, 1032804375, 589534241, -801, 805143596, 214363603, 1012921380, 803, 572778078, 396746770, 901124123, -804, 1006429495, 267954504, 997716269,
    807, 916444925, 420046468, 582805137, -808, 629018434, 570124749, 623572668, 810, 733155940, 336037174, 895740839, -811, 786273043, 175785024, 1047901291,
    813, 586524752, 268829739, 931341036, -814, 982841303, 1025037649, 236134790, 817, 938439603, 644875948, 631152199, -818, 614275814, 1043301714, 818672883,
    820, 750751682, 945397488, 504921759, -821, 767844768, 767256231, 486470192, 823, 600601346, 326821261, 189189042, -824, 959805960, 959070289, 339652284,
    827, 960962154, 93417288, 302702468, -828, 599878725, 599418930, 883371318, 830, 768769723, 289482195, 456910339, -831, 749848406, 1017709119, 567343235,
    833, 615015778, 661082485, 1009773366, -834, 937310508, 735265487, 440743588, 837, 984025245, 842983612, 756643926, -838, 585819067, 996411841, 678117926,
    840, 787220196, 674386890, 175818411, -841, 732273834, 977079346, 42341040, 843, 629776157, 324761147, 355403094, -844, 915342293, 684478270, 589797212,
    847, 1007641851, 734366200, 568644950, -848, 572088933, 562016647, 100187801, 850, 806113481, 372744595, 669664325, -851, 715111166, 970956264, 930541120,
    853, 644890785, 83447311, 750479825, -854, 893888958, 676824419, 89434576, 857, 1031825256, 133515698, 771270990, -858, 558680599, 154579805, 995420706,
    860, 825460204, 965806018, 187520062, -861, 698350748, 998531125, 438969514, 863, 660368163, 987393179, 364764415, -864, 872938436, 174422082, 817147349,
    867, 1056589062, 291338898, 154126334, -868, 545586522, 645884713, 779152549, 870, 845271249, 877316212, 982294526, -871, 681983153, 270484980, 168634318,
    873, 676216999, 916601335, 141590527, -874, 852478941, 606541681, 210792898, 876, 540973599, 948029432, 972265880, -877, 1065598676, 1026612557, 531926579,
    880, 865557759, 872601998, 267135220, -881, 665999173, 104761936, 466671840, 883, 692446207, 912829963, 428456541, -884, 832498966, 399387876, 583339800,
    886, 553956966, 300767241, 128016868, -887, 1040623707, 1036105757, 729174750, 890, 886331146, 51730856, 204826989, -891, 650389817, 513348370, 589951946,
    893, 709064916, 900378144, 163861591, -894, 812987271, 910120919, 200569021, 896, 567251933, 505554150, 560586002, -897, 1016234089, 869215692, 1056017644,
    900, 907603093, 594138276, 37944144, -901, 635146306, 140606624, 123140116, 903, 726082474, 904807350, 459852045, -904, 793932882, 712629192, 153925145,
    906, 580865979, 938594245, 153133271, -907, 992416103, 353915578, 192406431, 910, 929385567, 857505697, 889258329, -911, 620260064, 623850420, 388689475,
    913, 743508454, 256507828, 711406663, -914, 775325080, 779813025, 485861844, 916, 594806763, 419954627, 783873695, -917, 969156350, 974766281, 875762761,
    920, 951690821, 457179039, 609952818, -921, 605722719, 340793470, 144698542, 923, 761352657, 150994866, 917458984, -924, 757153399, 157556381, 717744089,
    926, 609082125, 765040987, 948715552, -927, 946441748, 1002251845, 91873743, 930, 974531401, 150323756, 658951424, -931, 591526093, 89536491, 191638817,
    933, 779625120, 979252464, 527161139, -934, 739407616, 380356069, 1044854890, 936, 623700096, 783401971, 636477276, -937, 924259520, 475445087, 500762245,
    940, 997920154, 823946424, 1018363642, -941, 577662200, 297153179, 715629587, 943, 798336123, 873905504, 814690913, -944, 722077750, 371441474, 626101527,
    946, 638668899, 54879309, 437004366, -947, 902597187, 1001172755, 245755997, 950, 1021870238, 517303624, 699206985, -951, 564123242, 491515244, 19379770,
    953, 817496190, 843339629, 344617223, -954, 705154053, 77523143, 24224713, 956, 653996952, 674671703, 490442143, -957, 881442566, 365339384, 835587259,
    960, 1046395124, 220481266, 355210700, -961, 550901603, 1033643483, 522242037, 963, 837116099, 391133377, 928413654, -964, 688627004, 1023618898, 384367090,
    966, 669692879, 527655067, 98485829, -967, 860783756, 205781798, 1017329775, 970, 1071508607, 200003012, 1016570786, -971, 537989847, 665484536, 367395653,
    973, 857206885, 804247504, 813256629, -974, 672487309, 563420214, 459244566, 976, 685765508, 643398003, 865353668, -977, 840609136, 972710724, 37184796,
    979, 548612406, 944215132, 692282934, -980, 1050761421, 142146581, 46480995, 983, 877779851, 7505658, 678155965, -984, 656725888, 223059341, 163268350,
    986, 702223880, 864997986, 113028042, -987, 820907360, 278824176, 472520894, 989, 561779104, 691998388, 949415893, -990, 1026134200, 348530220, 590651117,
    993, 898846567, 462952327, 874820335, -994, 641333875, 217831387, 906027860, 996, 719077253, 1014606956, 699856268, -997, 801667344, 3853778, 864099369,
    999, 575261803, 167440470, 989381744, -1000, 1002084180, 4817223, 543253299, 1003, 920418885, 53156388, 724017331, -1004, 626302612, 539881676, 742186496,
    1006, 736335108, 42525110, 1008710594, -1007, 782878265, 674852095, 927733120, 1009, 589068086, 463516818, 377471746, -1010, 978597832, 38258751, 891230944,
    1013, 942508938, 312130179, 818703158, -1014, 611623645, 23911719, 959672524, 1016, 754007150, 679200873, 440214162, -1017, 764529556, 298325105, 931155199,
    1019, 603205720, 543360698, 781668059, -1020, 955661945, 372906382, 358637631, 1023, 965129152, 869377117, 1035920530, -1024, 597288715, 904155128, 1029454887,
    1026, 772103322, 266004964, 828736424, -1027, 746610894, 861758455, 213076785, 1029, 617682657, 857049066, 233492409, -1030, 933263618, 540327156, 1071652349,
    1033, 988292252, 512285046, 803084585, -1034, 583289761, 606139929, 132911806, 1036, 790633801, 1054073131, 857216032, -1037, 729112201, 1026110367, 434575214,
    1039, 632507041, 628510140, 685772826, -1040, 911390252, 477331591, 274783562, 1043, 1012011266, 576119495, 452991427, -1044, 569618907, 835203156, 574392910,
    1046, 809609013, 246147231, 577141506, -1047, 712023634, 775568489, 717991137, 1049, 647687210, 626414514, 891209935, -1050, 890029543, 432589700, 92182554,
    1053, 1036299536, 1002263223, 781690801, -1054, 556268464, 673021746, 594485008, 1056, 829039629, 587062214, 195855911, -1057, 695335580, 841277183, 206235348,
    1059, 663231703, 684398136, 156684729, -1060, 869169475, 1051596478, 1063100553, 1063, 1061170725, 880288653, 35947202, -1064, 543230922, 523030071, 396002390,
    1066, 848936580, 704230922, 458254491, -1067, 679038653, 116916677, 226567531, 1069, 679149264, 563384737, 1010848687, -1070, 848798316, 414581302, 551644870,
    1072, 543319411, 665456155, 164433855, -1073, 1060997895, 518226628, 152685176, 1076, 869311058, 635233118, 692590898, -1077, 663123684, 726544826, 632299147,
    1079, 695448846, 937683224, 554072718, -1080, 828904605, 908181033, 253503021, 1082, 556359077, 535398214, 872754904, -1083, 1036130757, 329919923, 585314233,
    1086, 890174523, 1071385508, 537414388, -1087, 647581723, 340417680, 231603667, 1089, 712139619, 212863312, 429931510, -1090, 809477154, 157086644, 289504584,
    1092, 569711695, 385039014, 773441938, -1093, 1011846442, 733229217, 361880730, 1096, 911538712, 616062423, 593262006, -1097, 632404026, 726703716, 897264096,
    1099, 729230970, 63353209, 259861240, -1100, 790505033, 371508734, 47838297, 1102, 583384776, 50682567, 422637357, -1103, 988131291, 732821373, 596668783,
    1106, 933415641, 725337202, 246723042, -1107, 617582057, 323795630, 507135717, 1109, 746732513, 365521396, 1056371892, -1110, 771977571, 673179994, 97048734,
    1112, 597386010, 721913847, 200852419, -1113, 964971964, 573039536, 658181830, 1116, 955817617, 81320331, 536112236, -1117, 603107477, 895020622, 411363644,
    1119, 764654093, 709301359, 643638154, -1120, 753884347, 313469409, 1051075467, 1122, 611723274, 996937817, 300162158, -1123, 942355434, 123401306, 508537966,
    1126, 978757239, 950855413, 265511088, -1127, 588972146, 345561272, 586271684, 1129, 783005791, 975432695, 427157235, -1130, 736215182, 968822502, 732839605,
    1132, 626404633, 565597791, 556474153, -1133, 920268978, 674157216, 379178595, 1136, 1002247413, 690208101, 675610280, -1137, 575168111, 689783716, 236986622,
    1139, 801797930, 981663210, 969984954, -1140, 718960139, 593794189, 296233277, 1142, 641438344, 785330568, 775987963, -1143, 898700174, 473807280, 638727053,
    1146, 1026301351, 612283815, 597335646, -1147, 561687609, 27694094, 399204408, 1149, 821041081, 275078687, 692616882, -1150, 702109511, 303053073, 1035876422,
    1152, 656832865, 5314585, 339345141, -1153, 877636889, 110380886, 489539159, 1156, 1050932584, 8503336, 542952225, -1157, 548523055, 740076694, 37526518,
    1159, 840746067, 221551034, 4865050, -1160, 685653819, 656660411, 583779060, 1162, 672596853, 821485921, 648137135, -1163, 857067274, 552390058, 461288369,
    1165, 538077483, 12943642, 948006437, -1166, 1071334093, 153616661, 39739550, 1169, 860923972, 879703287, 872565205, -1170, 669583808, 230228141, 159054946,
    1172, 688739178, 274265900, 698052164, -1173, 836979760, 287785176, 467254139, 1175, 550991342, 648909450, 128945002, -1176, 1046224700, 359731470, 584067674,
    1179, 881586148, 179261660, 1065305462, -1180, 653890437, 761703081, 96606840, 1182, 705268918, 572906058, 422747640, -1183, 817363047, 146822483, 389194006,
    1185, 564215134, 887821576, 338198112, -1186, 1021703808, 988834472, 218057052, 1189, 902744215, 776269427, 755865344, -1190, 638564880, 618021545, 136285657,
    1192, 722195372, 621015542, 175195546, -1193, 798206100, 772526931, 438792528, 1195, 577756298, 67315704, 140156436, -1196, 997757625, 965658664, 280055204
  )
  
  // Returns the largest number we can we can add one digit to
  def parseLongMax(radix: Int, sign: Int): Long = {
    if (sign > 0) radixLastSafeSigned(radix)
    else if (sign < 0) radixLastSafeSigned(radix) + (if (((1L<<radix) & radixNegLastExtra) != 0) 1 else 0)
    else radixLastSafeUnsigned(radix)
  }
  
  val nonDigit10Delimiter = new Delimiter { def apply(c: Char) = c < '0' || c > '9' }
  val charsInInfinity = "INFINITY".toCharArray
  
  val nonDigit10DelimByte = new DelimByte { def apply(b: Byte) = b < '0' || b > '9' }
  val bytesInInfinity = "INFINITY".getBytes
}

trait GrokControl {
  def index: Int
  def indexTo(i: Int): this.type
  def error: Boolean
  def resume: this.type
}

abstract class GrokText extends GrokControl {
  import GrokNumber._
  import Delimiter._
  import DelimByte._
  
  private var j = 0
  def index = j
  def indexTo(i: Int): this.type = { j = i; this }
  
  protected var errorLevel = 0
  def error = errorLevel > 0
  def resume: this.type = { errorLevel = 0; this }
  
  
  def skipWhite(s: String)(limit: Int = s.length, delim: Delimiter = whiteDelimiter): this.type = {
    while (j < limit && delim(s(j))) j += 1
    this
  }
  def skipWhiteB(s: Array[Byte])(limit: Int = s.length, delim: DelimByte = whiteDelimByte): this.type = {
    while (j < limit && delim(s(j))) j += 1
    this
  }
  
  def skipBlack(s: String)(limit: Int = s.length, delim: Delimiter = whiteDelimiter): this.type = {
    while (j < limit && !delim(s(j))) j += 1
    this
  }
  def skipBlackB(s: Array[Byte])(limit: Int = s.length, delim: DelimByte = whiteDelimByte): this.type = {
    while (j < limit && !delim(s(j))) j += 1
    this
  }
  
  def skipToken(s: String)(limit: Int = s.length, delim: Delimiter = whiteDelimiter): this.type = {
    skipWhite(s)(limit,delim)
    skipBlack(s)(limit,delim)
  }
  def skipTokenB(s: Array[Byte])(limit: Int = s.length, delim: DelimByte = whiteDelimByte): this.type = {
    skipWhiteB(s)(limit,delim)
    skipBlackB(s)(limit,delim)
  }
  
  
  private[this] def myParseLong10(s: String, limit: Int, delim: Delimiter, unsigned: Boolean): Long = {
    if (j >= limit) { errorLevel = 2; return 0 }
    val sign = (if (s(j) == '-') { if (unsigned) { errorLevel = 2; return 0 }; j +=1; -1 } else if (unsigned) 0 else 1)
    var m = 922337203685477579L
    errorLevel = 0
    var v = 0L
    val j0 = j
    while (j < limit) {
      if (delim(s(j))) {
        if (j == j0) errorLevel = 2
        return if (sign < 0) -v else v
      }
      var c = s(j) - '0'
      if (c < 0 || c > 9) { errorLevel = 1; return v }
      val u = v*10 + c
      if (v >= m || v < 0) {
        if (m == 922337203685477579L) m = parseLongMax(10, sign)
        if (v > m || (sign > 0 && u < 0) || (sign < 0 && 0 < -u) || (sign == 0 && u >= 0 && u < v)) { errorLevel = 2; return v }
      }
      v = u
      j += 1
    }
    if (sign < 0) -v else v
  }
  private[this] def myParseLong(s: String, radix: Int, limit: Int, delim: Delimiter, unsigned: Boolean): Long = {
    if (j >= limit) { errorLevel = 2; return 0 }
    val sign = (if (s(j) == '-') { if (unsigned) { errorLevel = 2; return 0 }; j +=1; -1 } else if (unsigned) 0 else 1)
    var m = 256204778801521549L
    errorLevel = 0
    var v = 0L
    val j0 = 0
    while (j < limit) {
      if (delim(s(j))) {
        if (j == j0) errorLevel = 2
        return if (sign < 0) -v else v
      }
      var c = s(j) - '0'
      if (radix > 10 && c > 9) c = (c-7) & 0xFFDF
      if (c < 0 || c >= radix) { errorLevel = 1; return v }
      val u = v*radix + c
      if (v >= m || v < 0) {
        if (m == 256204778801521549L) m = parseLongMax(radix, sign)
        if (v > m || (sign > 0 && u < 0) || (sign < 0 && 0 < -u) || (sign == 0 && u >= 0 && u < v)) { errorLevel = 2; return v }
      }
      v = u
      j += 1
    }
    if (sign < 0) -v else v
  }
  private[this] def myParseLong10B(s: Array[Byte], limit: Int, delim: DelimByte, unsigned: Boolean): Long = {
    if (j >= limit) { errorLevel = 2; return 0 }
    val sign = (if (s(j) == '-') { if (unsigned) { errorLevel = 2; return 0 }; j +=1; -1 } else if (unsigned) 0 else 1)
    var m = 922337203685477579L
    errorLevel = 0
    var v = 0L
    val j0 = j
    while (j < limit) {
      if (delim(s(j))) {
        if (j == j0) errorLevel = 2
        return if (sign < 0) -v else v
      }
      var c = s(j) - '0'
      if (c < 0 || c > 9) { errorLevel = 1; return v }
      val u = v*10 + c
      if (v >= m || v < 0) {
        if (m == 922337203685477579L) m = parseLongMax(10, sign)
        if (v > m || (sign > 0 && u < 0) || (sign < 0 && 0 < -u) || (sign == 0 && u >= 0 && u < v)) { errorLevel = 2; return v }
      }
      v = u
      j += 1
    }
    if (sign < 0) -v else v
  }
  private[this] def myParseLongB(s: Array[Byte], radix: Int, limit: Int, delim: DelimByte, unsigned: Boolean): Long = {
    if (j >= limit) { errorLevel = 2; return 0 }
    val sign = (if (s(j) == '-') { if (unsigned) { errorLevel = 2; return 0 }; j +=1; -1 } else if (unsigned) 0 else 1)
    var m = 256204778801521549L
    errorLevel = 0
    var v = 0L
    val j0 = 0
    while (j < limit) {
      if (delim(s(j))) {
        if (j == j0) errorLevel = 2
        return if (sign < 0) -v else v
      }
      var c = s(j) - '0'
      if (radix > 10 && c > 9) c = (c-7) & 0xFFDF
      if (c < 0 || c >= radix) { errorLevel = 1; return v }
      val u = v*radix + c
      if (v >= m || v < 0) {
        if (m == 256204778801521549L) m = parseLongMax(radix, sign)
        if (v > m || (sign > 0 && u < 0) || (sign < 0 && 0 < -u) || (sign == 0 && u >= 0 && u < v)) { errorLevel = 2; return v }
      }
      v = u
      j += 1
    }
    if (sign < 0) -v else v
  }
  
  def rawParseLong(s: String, radix: Int)(limit: Int = s.length, delim: Delimiter = whiteDelimiter): Long = {
    if (radix == 10) myParseLong10(s, limit, delim, false) else myParseLong(s, radix, limit, delim, false)
  }
  def rawParseULong(s: String, radix: Int)(limit: Int = s.length, delim: Delimiter = whiteDelimiter): Long = {
    if (radix == 10) myParseLong10(s, limit, delim, true) else myParseLong(s, radix, limit, delim, true)
  }
  
  def rawParseLongB(s: Array[Byte], radix: Int)(limit: Int = s.length, delim: DelimByte = whiteDelimByte): Long = {
    if (radix == 10) myParseLong10B(s, limit, delim, false) else myParseLongB(s, radix, limit, delim, false)
  }
  def rawParseULongB(s: Array[Byte], radix: Int)(limit: Int = s.length, delim: DelimByte = whiteDelimByte): Long = {
    if (radix == 10) myParseLong10B(s, limit, delim, true) else myParseLongB(s, radix, limit, delim, true)
  }
  

  // Returns a Double from digits packed into digA and digB (ndig of them), with a decimal point at the position indicated
  def myDoubleConversion(neg: Boolean, digA: Long, digB: Int, ndig: Int, point: Int): Double = {
    if (ndig == point && ndig <= 18) digA.toDouble
    else if (point > ndig && point <= 18) {
      val v = digA * smallPowersOfTen(point - ndig)
      v.toDouble
    }
    else {
      val dA = if (ndig < 18) digA * smallPowersOfTen(18-ndig) else digA
      val dB = if (ndig <= 18) 0L else if (ndig < 27) digB * smallPowersOfTen(27-ndig) else digB
      val hA = dA/1000000000
      val hB = dA-hA*1000000000
      val hC = dB
      var pt = point - 9
      val i = 1 + (if (pt < 0) -8*pt-4 else 8*pt)
      pt -= 9
      val j = 1 + (if (pt < 0) -8*pt-4 else 8*pt)
      pt -= 9
      val k = 1 + (if (pt < 0) -8*pt-4 else 8*pt)
      var x = hB * tensToTwos(j)
      var y = hB * tensToTwos(j+1)
      (tensToTwos(j-1) - tensToTwos(i-1)) match {
        case q if q > 30 => x = x >> (q-30); y = y >> (q-30)
        case q if q < 30 => x = x << (30-q); y = y << (30-q)
        case _ =>
      }
      var z = hC * tensToTwos(k)
      (tensToTwos(k-1) - tensToTwos(i-1)) match {
        case q if q > 60 => z = z >> (q-60)
        case q if q < 60 => z = z << (60-q)
        case _ =>
      }
      val vC = hA * tensToTwos(i+2) + y + z
      val vB = hA * tensToTwos(i+1) + x + (vC >>> 30)
      val vA = hA * tensToTwos(i) + (vB >>> 30)
      var nz = 11 - java.lang.Long.numberOfLeadingZeros(vA)
      var w = ((vA << (16-nz)) | ((vB & 0x3FFFFFFF) >>> (nz+14))) & 0xFFFF
      var v0 = (vA >> nz)
      var v = v0 + ((w >> 15)&1)
      if ((v&0xFFE0000000000000L) != 0) {
        nz -= 1
        w = (w >> 1) + ((v0&1)<<15)
        v = (v0 >> 1) + (v0&1)
        v0 = (v0 >> 1)
      }
      if ((w&0x7FFF) >= 0x7FFE) errorLevel = 1  // May not be exact
      val ex = (0x3FFL - tensToTwos(i-1) + 22 + nz)
      val top = (ex << 52) | (if (neg) 0x8000000000000000L else 0)
      if (ex >= 2047) {
        if (neg) Double.NegativeInfinity else Double.PositiveInfinity
      }
      else if (ex < 0) {
        if (ex + 53 <= 0) { if (neg) -0.0 else 0.0 }
        else {
          v = (v0 >> (1-ex)) + ((v0 >> (-ex)) & 1)
          java.lang.Double.longBitsToDouble( (v & 0xFFFFFFFFFFFFFL) | (if (neg) 0x8000000000000000L else 0) )
        }
      }
      else java.lang.Double.longBitsToDouble( (v & 0xFFFFFFFFFFFFFL) | top )
    }
  }
  
  private[this] def myParseDouble10(s: String, limit: Int, delim: Delimiter, dot: Char): Double = {
    if (j >= limit) { errorLevel = 2; return parseErrorNaN }
    val j0 = j
    
    // Pull out the sign first
    val negative = s(j) match {
      case '-' => j += 1; true
      case '+' => j += 1; false
      case _ => false
    }
    if (j >= limit) { errorLevel = 2; return parseErrorNaN }
    val j1 = j
    
    // Handle NaN and the infinities
    if ((s(j) & 0xFFDF) == 'N') {
      if (j+2 >= limit || !((s(j+1) & 0xFFDF) == 'A') || !((s(j+2) & 0xFFDF) == 'N')) { errorLevel = 2; return parseErrorNaN }
      j += 2
      if (j < limit && !delim(s(j))) errorLevel = 1
      return Double.NaN
    }
    if ((s(j) & 0xFFDF) == 'I') {
      j += 1
      var k = 1
      while (j < limit && k < charsInInfinity.length && s(j) == charsInInfinity(k)) { j += 1; k += 1 }
      if (k != 3 && k != charsInInfinity.length) { errorLevel = 2; return parseErrorNaN }
      if (j < limit && !delim(s(j))) errorLevel = 1
      return if (negative) Double.NegativeInfinity else Double.PositiveInfinity
    }
    
    // If we reach this point, it's supposed to be an actual number
    
    // Just count any leading zeros
    while (j < limit && s(j) == '0') j += 1
    val j2 = j
    
    // Get ready to parse something substantive
    errorLevel = 0
    val notdig = nonDigit10Delimiter
    var ndig = 0
    var digA, digB = -1L
    
    // Handle any digits before the decimal point or exponent
    if (j < limit && !notdig(s(j))) {
      digA = myParseLong10(s, math.min(limit, j+18), delim, true)
      if (errorLevel > 1) return parseErrorNaN
      ndig = j - j2
      if (ndig == 18 && j < limit && !notdig(s(j))) {
        digB = myParseLong10(s, math.min(limit, j+18), delim, true)
        if (errorLevel > 1) return parseErrorNaN
        ndig = j - j2
        if (ndig == 27) while (j < limit && !notdig(s(j))) j += 1
      }
      errorLevel = 0
    }
    
    // Keep track of where the decimal point was
    var point = j - j2
    
    // Handle any digits after the decimal point
    if (j < limit && s(j) == dot) {
      j += 1
      val jd0 = j
      
      // Skip leading zeros
      while (j < limit && s(j) == '0') j += 1
      
      // Special case of no (nonzero) digits before decimal point--is it exactly zero or an error?
      if (ndig == 0 && (j >= limit || notdig(s(j)))) {
        if (j == j1+1) { errorLevel = 2; return parseErrorNaN }   // No actual numbers
        if (j < limit && ((s(j)&0xFFDF) == 'E')) {
          // Need to parse and ignore exponent
          j += 1
          if (j < limit && (s(j)=='+' || s(j)=='-')) j += 1
          if (j >= limit || notdig(s(j))) { errorLevel = 2; return parseErrorNaN }
          while (j < limit && !notdig(s(j))) j += 1
          if (j < limit && !delim(s(j))) errorLevel = 1
        }
        else {
          if (j < limit && !delim(s(j))) errorLevel = 1
        }
        // Might be an error, but return the correct sign anyway
        return (if (negative) -0.0 else 0)
      }
      
      if (ndig == 0) point = -(j - jd0)
      
      // Read non-zeros if we have any
      if (j < limit && !notdig(s(j))) {
        // Put zeros back into existing Longs if need be
        if (j > jd0 && ndig > 0) {
          var nz = j - jd0
          if (ndig < 18) {
            val n = math.min(18 - ndig, nz)
            digA = digA*smallPowersOfTen(n)
            nz -= n
            ndig += n
          }
          if (nz > 0 && ndig < 27) {
            if (ndig == 18) {
              digB = 0
              ndig = math.min(27, ndig+nz)
            }
            else {
              val n = math.min(27-ndig, nz)
              digB = digB*smallPowersOfTen(n)
              ndig += n
            }
          }
        }
        // Read more digits
        val jd1 = j
        val nread = if (ndig < 18) 18 - ndig else 27-ndig
        if (nread > 0) {
          val value = myParseLong10(s, math.min(limit, j+nread), delim, true)
          if (errorLevel > 1) return parseErrorNaN
          if (ndig == 0) {
            digA = value
            ndig = j - jd1
          }
          else {
            if (ndig < 18) digA = digA*smallPowersOfTen(j-jd1) + value
            else if (ndig == 18) digB = value
            else digB = digB*smallPowersOfTen(j-jd1) + value
            ndig += (j - jd1)
          }
          if (ndig < 27 && j < limit && !notdig(s(j))) {
            val jd2 = j
            val nread2 = 27 - ndig
            val value2 = myParseLong10(s, math.min(limit, jd2+nread2), notdig, true)
            if (errorLevel > 1) return parseErrorNaN
            if (ndig == 18) digB = value2
            else digB = digB*smallPowersOfTen(nread2-(j-jd2)) + value2
            ndig += (j-jd2)
          }
          errorLevel = 0
        }
        while (j < limit && !notdig(s(j))) j += 1
      }
      
      // Check to make sure we got at least some digit somewhere
      if (jd0 == j1+1 && j==jd0) {
        errorLevel = 2
        return parseErrorNaN
      }
    }
    else {
      // No dot, so check to make sure we had a digit before the dot
      if (j == j1) {
        errorLevel = 2
        return parseErrorNaN
      }
    }
    
    // Now we need to parse an exponent if there is one
    if (j+1 < limit && ((s(j) & 0xFFDF) == 'E')) {
      j += 1
      val negexp = s(j) match {
        case '+' => j += 1; 1
        case '-' => j += 1; -1
        case _ => 1
      }
      val expval = myParseLong10(s, math.min(s.length, j+10), delim, true)
      if (j < limit && !delim(s(j)) && errorLevel < 1) errorLevel = 1
      if (errorLevel > 1) return parseErrorNaN
        
      // Handle clearly over-large and under-small cases
      val pt = expval*negexp + point
      if (pt > 312) return (if (negative) Double.NegativeInfinity else Double.PositiveInfinity)
      if (pt < -328) return (if (negative) -0.0 else 0.0)
      point = pt.toInt
    }

    // Zero is boring, handle it separately
    if (ndig == 0) return 0
      
    // Process the results
    val ans = myDoubleConversion(negative, digA, digB.toInt, ndig, point)
    if (errorLevel > 0) {
      errorLevel = 0
      try { s.substring(j0,j).toDouble }
      catch { case _: NumberFormatException => errorLevel = 2; return parseErrorNaN }
    }
    else ans
  }
  private[this] def myParseDouble10B(s: Array[Byte], limit: Int, delim: DelimByte, dot: Byte): Double = {
    if (j >= limit) { errorLevel = 2; return parseErrorNaN }
    val j0 = j
    
    // Pull out the sign first
    val negative = s(j) match {
      case '-' => j += 1; true
      case '+' => j += 1; false
      case _ => false
    }
    if (j >= limit) { errorLevel = 2; return parseErrorNaN }
    val j1 = j
    
    // Handle NaN and the infinities
    if ((s(j) & 0xFFDF) == 'N') {
      if (j+2 >= limit || !((s(j+1) & 0xFFDF) == 'A') || !((s(j+2) & 0xFFDF) == 'N')) { errorLevel = 2; return parseErrorNaN }
      j += 2
      if (j < limit && !delim(s(j))) errorLevel = 1
      return Double.NaN
    }
    if ((s(j) & 0xFFDF) == 'I') {
      j += 1
      var k = 1
      while (j < limit && k < charsInInfinity.length && s(j) == charsInInfinity(k)) { j += 1; k += 1 }
      if (k != 3 && k != charsInInfinity.length) { errorLevel = 2; return parseErrorNaN }
      if (j < limit && !delim(s(j))) errorLevel = 1
      return if (negative) Double.NegativeInfinity else Double.PositiveInfinity
    }
    
    // If we reach this point, it's supposed to be an actual number
    
    // Just count any leading zeros
    while (j < limit && s(j) == '0') j += 1
    val j2 = j
    
    // Get ready to parse something substantive
    errorLevel = 0
    val notdig = nonDigit10DelimByte
    var ndig = 0
    var digA, digB = -1L
    
    // Handle any digits before the decimal point or exponent
    if (j < limit && !notdig(s(j))) {
      digA = myParseLong10B(s, math.min(limit, j+18), delim, true)
      if (errorLevel > 1) return parseErrorNaN
      ndig = j - j2
      if (ndig == 18 && j < limit && !notdig(s(j))) {
        digB = myParseLong10B(s, math.min(limit, j+18), delim, true)
        if (errorLevel > 1) return parseErrorNaN
        ndig = j - j2
        if (ndig == 27) while (j < limit && !notdig(s(j))) j += 1
      }
      errorLevel = 0
    }
    
    // Keep track of where the decimal point was
    var point = j - j2
    
    // Handle any digits after the decimal point
    if (j < limit && s(j) == dot) {
      j += 1
      val jd0 = j
      
      // Skip leading zeros
      while (j < limit && s(j) == '0') j += 1
      
      // Special case of no (nonzero) digits before decimal point--is it exactly zero or an error?
      if (ndig == 0 && (j >= limit || notdig(s(j)))) {
        if (j == j1+1) { errorLevel = 2; return parseErrorNaN }   // No actual numbers
        if (j < limit && ((s(j)&0xFFDF) == 'E')) {
          // Need to parse and ignore exponent
          j += 1
          if (j < limit && (s(j)=='+' || s(j)=='-')) j += 1
          if (j >= limit || notdig(s(j))) { errorLevel = 2; return parseErrorNaN }
          while (j < limit && !notdig(s(j))) j += 1
          if (j < limit && !delim(s(j))) errorLevel = 1
        }
        else {
          if (j < limit && !delim(s(j))) errorLevel = 1
        }
        // Might be an error, but return the correct sign anyway
        return (if (negative) -0.0 else 0)
      }
      
      if (ndig == 0) point = -(j - jd0)
      
      // Read non-zeros if we have any
      if (j < limit && !notdig(s(j))) {
        // Put zeros back into existing Longs if need be
        if (j > jd0 && ndig > 0) {
          var nz = j - jd0
          if (ndig < 18) {
            val n = math.min(18 - ndig, nz)
            digA = digA*smallPowersOfTen(n)
            nz -= n
            ndig += n
          }
          if (nz > 0 && ndig < 27) {
            if (ndig == 18) {
              digB = 0
              ndig = math.min(27, ndig+nz)
            }
            else {
              val n = math.min(27-ndig, nz)
              digB = digB*smallPowersOfTen(n)
              ndig += n
            }
          }
        }
        // Read more digits
        val jd1 = j
        val nread = if (ndig < 18) 18 - ndig else 27-ndig
        if (nread > 0) {
          val value = myParseLong10B(s, math.min(limit, j+nread), delim, true)
          if (errorLevel > 1) return parseErrorNaN
          if (ndig == 0) {
            digA = value
            ndig = j - jd1
          }
          else {
            if (ndig < 18) digA = digA*smallPowersOfTen(j-jd1) + value
            else if (ndig == 18) digB = value
            else digB = digB*smallPowersOfTen(j-jd1) + value
            ndig += (j - jd1)
          }
          if (ndig < 27 && j < limit && !notdig(s(j))) {
            val jd2 = j
            val nread2 = 27 - ndig
            val value2 = myParseLong10B(s, math.min(limit, jd2+nread2), delim, true)
            if (errorLevel > 1) return parseErrorNaN
            if (ndig == 18) digB = value2
            else digB = digB*smallPowersOfTen(nread2-(j-jd2)) + value2
            ndig += (j-jd2)
          }
        }
        while (j < limit && !notdig(s(j))) j += 1
        errorLevel = 0
      }
      
      // Check to make sure we got at least some digit somewhere
      if (jd0 == j1+1 && j==jd0) {
        errorLevel = 2
        return parseErrorNaN
      }
    }
    else {
      // No dot, so check to make sure we had a digit before the dot
      if (j == j1) {
        errorLevel = 2
        return parseErrorNaN
      }
    }
    
    // Now we need to parse an exponent if there is one
    if (j+1 < limit && ((s(j) & 0xFFDF) == 'E')) {
      j += 1
      val negexp = s(j) match {
        case '+' => j += 1; 1
        case '-' => j += 1; -1
        case _ => 1
      }
      val expval = myParseLong10B(s, math.min(s.length, j+10), delim, true)
      if (j < limit && !delim(s(j)) && errorLevel < 1) errorLevel = 1
      if (errorLevel > 1) return parseErrorNaN
        
      // Handle clearly over-large and under-small cases
      val pt = expval*negexp + point
      if (pt > 312) return (if (negative) Double.NegativeInfinity else Double.PositiveInfinity)
      if (pt < -328) return (if (negative) -0.0 else 0.0)
      point = pt.toInt
    }

    // Zero is boring, handle it separately
    if (ndig == 0) return 0
      
    // Process the results
    val ans = myDoubleConversion(negative, digA, digB.toInt, ndig, point)
    if (errorLevel == 1) {
      errorLevel = 0
      try { (new String(s, j0, j-j0)).toDouble }
      catch { case _: NumberFormatException => errorLevel = 2; return parseErrorNaN }
    }
    else ans
  }
  
  def rawParseDouble(s: String, dot: Char = '.')(limit: Int = s.length, delim: Delimiter = whiteDelimiter) = myParseDouble10(s, limit, delim, dot)
  def rawParseDoubleB(s: Array[Byte], dot: Byte = '.'.toByte)(limit: Int = s.length, delim: DelimByte = whiteDelimByte) = myParseDouble10B(s, limit, delim, dot)
  
  
  def rawParseExact(s: String, token: String)(limit: Int = s.length, delim: Delimiter = whiteDelimiter) {
    if (j + token.length >= limit) {
      j = limit
      errorLevel = 2
    }
    else {
      errorLevel = 0
      var i = 0
      while (j < limit && i < token.length && s(j)==token(i)) { j += 1; i += 1 }
      if (j < limit && !delim(s(j))) errorLevel = 1
    }
  }
  def rawParseExactB(s: Array[Byte], token: String)(limit: Int = s.length, delim: DelimByte = whiteDelimByte) {
    if (j + token.length >= limit) {
      j = limit
      errorLevel = 2
    }
    else {
      errorLevel = 0
      var i = 0
      while (j < limit && i < token.length && s(j)==token(i)) { j += 1; i += 1 }
      if (j < limit && !delim(s(j))) errorLevel = 1
    }
  }
  
  
  def rawParseToken(s: String)(limit: Int = s.length, delim: Delimiter = whiteDelimiter): String = {
    errorLevel = if (j >= limit) 2 else 0
    val i = j
    while (j < limit && !delim(s(j))) j += 1
    s.substring(i,j)
  }
  def rawParseTokenB(s: Array[Byte])(limit: Int = s.length, delim: DelimByte = whiteDelimByte): Array[Byte] = {
    errorLevel = if (j >= limit) 2 else 0
    val i = j
    while (j < limit && !delim(s(j))) j += 1
    java.util.Arrays.copyOfRange(s, i, j)
  }
  
  
  def rawParseCodePoint(s: String)(limit: Int = s.length): Int = {
    if (j >= limit) { errorLevel = 2; return 0x80000000 }
    val c = s(j).toInt
    errorLevel = 0
    if (c < 0xD800 || c > 0xDFFF) {
      j += 1
      c
    }
    else if (c >= 0xDC00 || j+1 >= limit) { errorLevel = 2; return 0x8000000 | c }
    else {
      val cc = s(j+1).toInt
      if (cc < 0xDC00 || cc > 0xDFFF) { errorLevel = 2; return (c<<16) | cc }
      j += 2
      (((c & 0x3FF) << 10) | ((cc & 0x3FF))) + 0x10000
    }
  }
  def rawParseCodePointB(s: Array[Byte], allowLongZero: Boolean = false, allowD800: Boolean = false)(limit: Int = s.length): Int = {
    if (j >= limit) { errorLevel = 2; return 0x80000000 }
    val c = s(j)
    errorLevel = 0
    if ((c&0x80) == 0) { j += 1; c.toInt }
    else if ((c&0xC0) == 0x80 || j+1 >= limit) { errorLevel = 2; return 0x80000000 | c.toInt }
    else if ((c&0xE0) == 0xC0) {
      val cc = s(j+1)
      if ((cc&0xC0) != 0x80) { errorLevel = 2; return 0x80000000 | (c.toInt << 8) | (cc.toInt) }
      val ans = ((c & 0x1F) << 6) | (cc & 0x3F)
      if (ans <= 0x7F && !(allowLongZero && ans==0)) { errorLevel = 2; return 0x80000000 | (c.toInt << 8) | (cc.toInt) }
      j += 2
      ans
    }
    else if (j+2 >= limit) { errorLevel = 2; return 0x80000000 | c.toInt }
    else if ((c&0xF0) == 0xE0) {
      val cc = s(j+1)
      val ccc = s(j+2)
      if ((cc&0xC0) != 0x80 || (ccc&0xC0) != 0x80) { errorLevel = 2; return 0x80000000 | (c.toInt << 16) | (cc.toInt << 8) | (ccc.toInt) }
      val ans = ((c & 0xF) << 12) | ((cc & 0x3F) << 6) | (ccc &0x3F)
      if (ans <= 0x7FF || (!allowD800 && (ans & 0xF800) == 0xD800)) { errorLevel = 2; return 0x80000000 | (c.toInt << 16) | (cc.toInt << 8) | (ccc.toInt) }
      j += 3
      ans
    }
    else if (j+3 >= limit || !((c&0xF8)==0xF0)) { errorLevel = 2; return 0x80000000 | c.toInt }
    else {
      val cc = s(j+1)
      val ccc = s(j+2)
      val cccc = s(j+3)
      if ((cc&0xC0) != 0x80 || (ccc&0xC0) != 0x80 || (cccc&0xC0) != 0x80) { errorLevel = 2; return (c.toInt << 24) | (cc.toInt << 16) | (ccc.toInt << 8) | cccc.toInt }
      val ans = ((c & 0x7) << 18) | ((cc & 0x3F) << 12) | ((ccc & 0x3F) << 6) | (cccc & 0x3F);
      if (ans >= 0xFFFF || ans >= 0x110000) { errorLevel = 2; return (c.toInt << 24) | (cc.toInt << 16) | (ccc.toInt << 8) | cccc.toInt }
      j += 4
      ans
    }
  }
  
  def rawParseCharB(s: Array[Byte], allowLongZero: Boolean = false, allowD800: Boolean = false)(limit: Int = s.length): Char = {
    if (j >= limit) { errorLevel = 2; return 0xDC00 }
    val c = s(j)
    errorLevel = 0
    if ((c&0x80) == 0) { j += 1; c.toChar }
    else if ((c&0xC0) == 0xC0) {
      val j0 = j
      val i = rawParseCodePointB(s, allowLongZero, allowD800)(limit)
      if (errorLevel > 1) return 0xDC00
      if (i > 0xFFFF) { j = j0+1; (0xD800 | ((i-0x10000) >> 10)).toChar }
      else i.toChar
    }
    else {
      val j0 = j
      while (j > 0 && ((s(j-1)&0xC0) == 0x80)) j -= 1
      val i = rawParseCodePointB(s, allowLongZero, allowD800)(limit)
      if (errorLevel > 1) { j = j0; return 0xDC00 }
      if (i <= 0xFFFF) { errorLevel = 2; return 0xDC00 }
      if (j <= j0) { errorLevel = 2; return 0xDC00 }
      ((i - 0x10000) & 0x3FF).toChar
    }
  } 
  
  
  def rawParseString(s: String, qL: Char = '"', qR: Char = '"', esc: Char = '\\')(limit: Int = s.length): String = {
    if (j >= limit || s(j) != qL) { errorLevel = 2; return "" }
    j += 1
    val j0 = j
    var c: Char = ' '
    var nesc = 0
    while (j < limit && { c = s(j); c != qR }) if (c == esc) { nesc += 1; j += 2 } else j += 1
    if (j <= limit) { j = limit; errorLevel = 2; return "" }
    if (c != qR) { errorLevel = 2; return "" }
    errorLevel = 0
    if (nesc == 0) {
      j += 1
      s.substring(j0, j-1)
    }
    else {
      val ac = new Array[Char](j-j0-nesc)
      var k = 0
      j = j0
      while (j < limit && { c = s(j); c != qR }) if (c == esc) { ac(k) = s(j+1); k += 1; j += 2 } else { ac(k) = c; k +=1; j += 1 }
      new String(ac)
    }
  }
  
  def rawParseStringB(s: Array[Byte], qL: Byte = '"'.toByte, qR: Byte = '"'.toByte, esc: Byte = '\\'.toByte)(limit: Int = s.length, charset: Option[java.nio.charset.Charset] = None): String = {
    if (j >= limit || s(j) != qL) { errorLevel = 2; return "" }
    j += 1
    val j0 = j
    var c: Byte = 0
    var nesc = 0
    while (j < limit && { c = s(j); c != qR }) if (c == esc) { nesc += 1; j += 2 } else j += 1
    if (j <= limit) { j = limit; errorLevel = 2; return "" }
    if (c != qR) { errorLevel = 2; return "" }
    errorLevel = 0
    if (nesc == 0) {
      j += 1
      charset match {
        case None => new String(s, j0, j-1-j0)
        case Some(cs) => new String(s, j0, j-1-j0, cs)
      }
    }
    else {
      val ac = new Array[Byte](j-j0-nesc)
      var k = 0
      j = j0
      while (j < limit && { c = s(j); c != qR }) if (c == esc) { ac(k) = s(j+1); k += 1; j += 2 } else { ac(k) = c; k +=1; j += 1 }
      charset match {
        case None => new String(ac)
        case Some(cs) => new String(ac, cs)
      }
    }
  }

  def inToken: Boolean
  def exact(target: String)(implicit oops: Oops): Unit
  def until(delim: Delimiter)(implicit oops: Oops): String
  def until(delim: DelimByte)(implicit oops: Oops): String
}

trait Grok {
  def hasNext: Boolean
  def hasPrev: Boolean
  def inToken: Boolean
  def skip(implicit oops: Oops): this.type
  def skip(n: Int)(implicit oops: Oops): this.type = { var i = n; while (i>0) { skip; i -= 1}; this }
  def drop(n: Int): this.type = { var i = n; while (i>0 && hasNext) { skip(oopsThrowingRealException); i -= 1}; this }
  def back(implicit oops: Oops): this.type
  def back(n: Int)(implicit oops: Oops): this.type = { var i = n; while (i>0) { back; i -= 1}; this }
  def undrop(n: Int): this.type = { var i = n; while (i>0 && hasPrev) { back(oopsThrowingRealException); i -= 1}; this }
  
  def Z(implicit oops: Oops): Boolean
  def B(implicit oops: Oops): Byte
  def S(implicit oops: Oops): Short
  def C(implicit oops: Oops): Char
  def I(implicit oops: Oops): Int
  def L(implicit oops: Oops): Long
  def F(implicit oops: Oops): Float
  def D(implicit oops: Oops): Double
  def tok(implicit oops: Oops): String
  def quoted(implicit oops: Oops): String
  def base64(coder: kse.eio.base64.Base64)(implicit oops: Oops): Array[Byte] = coder.decode(tok)
  def until(delim: Delimiter)(implicit oops: Oops): String
  def until(delim: DelimByte)(implicit oops: Oops): String
  def exact(target: String)(implicit oops: Oops): Unit
  def select(targets: Array[String])(implicit oops: Oops): Int
  
  def tapZ[A](f: Boolean => A)(implicit oops: Oops): this.type = { f(Z); this }
  def tapB[A](f: Byte => A)(implicit oops: Oops): this.type = { f(B); this }
  def tapS[A](f: Short => A)(implicit oops: Oops): this.type = { f(S); this }
  def tapC[A](f: Char => A)(implicit oops: Oops): this.type = { f(C); this }
  def tapI[A](f: Int => A)(implicit oops: Oops): this.type = { f(I); this }
  def tapL[A](f: Long => A)(implicit oops: Oops): this.type = { f(L); this }
  def tapF[A](f: Float => A)(implicit oops: Oops): this.type = { f(F); this }
  def tapD[A](f: Double => A)(implicit oops: Oops): this.type = { f(D); this }
  def tapTok[A](f: String => A)(implicit oops: Oops): this.type = { f(tok); this }
  def tapQuoted[A](f: String => A)(implicit oops: Oops): this.type = { f(quoted); this }
  def tapBase64[A](coder: kse.eio.base64.Base64)(f: Array[Byte] => A)(implicit oops: Oops): this.type = { f(base64(coder)); this }
  def tapUntil[A](delim: Delimiter)(f: String => A)(implicit oops: Oops): this.type = { f(until(delim)); this }
  def tapUntil[A](delim: DelimByte)(f: String => A)(implicit oops: Oops): this.type = { f(until(delim)); this }
  def tapExact[A](f: => A)(implicit oops: Oops): this.type = { f; this }
  def tapSelect[A](targets: Array[String])(f: (Int,String) => A)(implicit oops: Oops): this.type = { val i = select(targets); f(i, targets(i)); this }
}

trait GrokFullDelim extends Grok {
  def getZs(a: Array[Boolean], offset: Int, count: Int)(implicit oops: Oops): this.type = { var i=offset; val n = offset+count; while (i<n) { a(i) = Z; i += 1 }; this }
  def getBs(a: Array[Byte], offset: Int, count: Int)(implicit oops: Oops): this.type = { var i=offset; val n = offset+count; while (i<n) { a(i) = B; i += 1 }; this }
  def getSs(a: Array[Short], offset: Int, count: Int)(implicit oops: Oops): this.type = { var i=offset; val n = offset+count; while (i<n) { a(i) = S; i += 1 }; this }
  def getCs(a: Array[Char], offset: Int, count: Int)(implicit oops: Oops): this.type = { var i=offset; val n = offset+count; while (i<n) { a(i) = C; i += 1 }; this }
  def getIs(a: Array[Int], offset: Int, count: Int)(implicit oops: Oops): this.type = { var i=offset; val n = offset+count; while (i<n) { a(i) = I; i += 1 }; this }
  def getLs(a: Array[Long], offset: Int, count: Int)(implicit oops: Oops): this.type = { var i=offset; val n = offset+count; while (i<n) { a(i) = L; i += 1 }; this }
  def getFs(a: Array[Float], offset: Int, count: Int)(implicit oops: Oops): this.type = { var i=offset; val n = offset+count; while (i<n) { a(i) = F; i += 1 }; this }
  def getDs(a: Array[Double], offset: Int, count: Int)(implicit oops: Oops): this.type = { var i=offset; val n = offset+count; while (i<n) { a(i) = D; i += 1 }; this }
  def getToks(a: Array[String], offset: Int, count: Int)(implicit oops: Oops): this.type = { var i=offset; val n = offset+count; while (i<n) { a(i) = tok; i += 1 }; this }
  def getQuotes(a: Array[String], offset: Int, count: Int)(implicit oops: Oops): this.type = { var i=offset; val n = offset+count; while (i<n) { a(i) = quoted; i += 1 }; this }
  def getBase64s(coder: kse.eio.base64.Base64)(a: Array[Array[Byte]], offset: Int, count: Int)(implicit oops: Oops): this.type = { var i=offset; val n = offset+count; while (i<n) { a(i) = base64(coder); i += 1 }; this }
  def getSelects(targets: Array[String])(a: Array[Int], offset: Int, count: Int)(implicit oops: Oops): this.type = { var i=offset; val n = offset+count; while (i<n) { a(i) = select(targets); i += 1 }; this }
}

trait GrokStringControl extends GrokControl {
  def string: String
  def reset: this.type
  def resetWith(s: String, start: Int, limit: Int): this.type
  def setDelimiter(delim: Delimiter): this.type
}

trait GrokArrayControl extends GrokControl {
  def bytes: Array[Byte]
  def reset: this.type
  def resetWith(a: Array[Byte], start: Int, limit: Int): this.type
}

trait GrokArrayBinaryControl extends GrokArrayControl {
  def bigEndian(big: Boolean): this.type  
  def hasNext(n: Int): Boolean
  def hasPrev(n: Int): Boolean
}

trait GrokArrayTextControl extends GrokArrayControl {
  def setDelimiter(delim: DelimByte): this.type  
  def inToken: Boolean
  def until(delim: DelimByte)(implicit oops: Oops): String
  def exact(target: String)(implicit oops: Oops): Unit
}

object Grok {
  def apply(s: String): GrokFullDelim = raw(s, 0, s.length, Delimiter.whiteDelimiter)
  def apply(s: String, delimiter: Delimiter): GrokFullDelim = raw(s, 0, s.length, delimiter)
  def apply(s: String, start: Int, limit: Int): GrokFullDelim = raw(s, start, limit, Delimiter.whiteDelimiter)
  def apply(s: String, start: Int, limit: Int, delimiter: Delimiter): GrokFullDelim = raw(s, start, limit, delimiter)
  def selfDelim(s: String): Grok = rawSelfDelim(s, 0, s.length, Delimiter.whiteDelimiter)
  def selfDelim(s: String, delimiter: Delimiter): Grok = rawSelfDelim(s, 0, s.length, delimiter)
  def selfDelim(s: String, start: Int, limit: Int): Grok = rawSelfDelim(s, start, limit, Delimiter.whiteDelimiter)
  def selfDelim(s: String, start: Int, limit: Int, delimiter: Delimiter): Grok = rawSelfDelim(s, start, limit, delimiter)
  def raw(s: String, start: Int, limit: Int, delimiter: Delimiter): GrokText with GrokStringControl with GrokFullDelim = 
    new GrokTextStringControlImpl(s, start, limit, delimiter)
  def rawSelfDelim(s: String, start: Int, limit: Int, delimiter: Delimiter): GrokText with GrokStringControl with Grok =
    new GrokTextStringControlImpl(s, start, limit, delimiter) { override def error = errorLevel > 1 }
  
  private class GrokTextStringControlImpl(s: String, start: Int, limit: Int, delimiter: Delimiter) extends GrokText with GrokStringControl with GrokFullDelim {
    private[this] var myString = s
    private[this] var myZero = math.min(s.length, math.max(start, 0))
    private[this] var myLimit = math.min(s.length, math.max(myZero, limit))
    private[this] var myDelim = Delimiter.whiteDelimiter
    
    def string = myString
    def reset = indexTo(myZero).resume
    def resetWith(s: String, start: Int, limit: Int) = {
      myString = s; myZero = math.min(s.length, math.max(0, start)); myLimit = math.min(s.length, math.max(myZero, limit))
      reset
    }
    def setDelimiter(delim: Delimiter) = { myDelim = delim; this }
    
    def inToken = index < myLimit && !myDelim(s(index))
    def hasNext = {
      val i = index
      (i < myLimit) && (!myDelim(s(i)) || {
        skipWhite(s)(myLimit, myDelim)
        index < myLimit
      })
    }
    def hasPrev: Boolean = {
      val i = index-1
      (i > myZero) && (!myDelim(s(i))) || {
        var j = i-1
        while (j >= myZero) {
          if (!myDelim(s(j))) {
            indexTo(j+1)
            return true
          }
          j -= 1
        }
        false
      }
    }
    def skip(implicit oops: Oops) = if (hasNext) { skipBlack(s)(myLimit, myDelim); this } else OOPS
    def back(implicit oops: Oops) = if (hasPrev) {
      var i = index-1
      while (i > myZero && !myDelim(s(i))) i -= 1
      indexTo(i)
      this
    } else OOPS
    
    def Z(implicit oops: Oops): Boolean = {
      skipWhite(myString)(myLimit, myDelim)
      val ans = rawParseToken(myString)(myLimit, myDelim)
      if (error) OOPS
      ans.toLowerCase match {
        case "yes" | "y" | "true" | "t" => true
        case "no" | "n" | "false" | "f" => false
        case _ => OOPS
      }
    }
    def B(implicit oops: Oops): Byte = {
      skipWhite(myString)(myLimit, myDelim)
      val ans = rawParseLong(myString, 10)(myLimit, myDelim)
      if (error || ans < -128 || ans > 255) OOPS
      (ans&0xFF).toByte
    }
    def S(implicit oops: Oops): Short = {
      skipWhite(myString)(myLimit, myDelim)
      val ans = rawParseLong(myString, 10)(myLimit, myDelim)
      if (error || ans < Short.MinValue || ans > Short.MaxValue) OOPS
      (ans&0xFFFF).toShort
    }
    def C(implicit oops: Oops): Char = {
      val i = index
      if (i < myLimit) myString(i) else OOPS
    }
    def I(implicit oops: Oops): Int = {
      skipWhite(myString)(myLimit, myDelim)
      val ans = rawParseLong(myString, 10)(myLimit, myDelim)
      if (error | ans < Int.MinValue || ans > Int.MaxValue) OOPS
      (ans&0xFFFFFFFFL).toInt
    }
    def L(implicit oops: Oops): Long = {
      skipWhite(myString)(myLimit, myDelim)
      val ans = rawParseLong(myString, 10)(myLimit, myDelim)
      if (error) OOPS
      ans
    }
    def F(implicit oops: Oops): Float = {
      skipWhite(myString)(myLimit, myDelim)
      val ans = rawParseDouble(myString)(myLimit, myDelim)
      if (error) OOPS
      ans.toFloat
    }
    def D(implicit oops: Oops): Double = {
      skipWhite(myString)(myLimit, myDelim)
      val ans = rawParseDouble(myString)(myLimit, myDelim)
      if (error) OOPS
      ans
    }
    def tok(implicit oops: Oops): String = {
      skipWhite(myString)(myLimit, myDelim)
      val ans = rawParseToken(myString)(myLimit, myDelim)
      if (error) OOPS
      ans
    }
    def quoted(implicit oops: Oops): String = {
      skipWhite(myString)(myLimit, myDelim)
      val ans = rawParseString(myString)(myLimit)
      if (error) OOPS
      ans
    }
    def exact(target: String)(implicit oops: Oops) {
      skipWhite(myString)(myLimit, myDelim)
      rawParseExact(myString, target)(myLimit, myDelim)
      if (error) OOPS
    }
    def select(targets: Array[String])(implicit oops: Oops): Int = {
      if (targets.length < 1) OOPS
      skipWhite(myString)(myLimit, myDelim)
      val j0 = index
      var i = -1
      do {
        i += 1
        indexTo(j0)
        rawParseExact(myString, targets(i))(myLimit, myDelim)
      } while (error);
      if (error) OOPS
      i - 1
    }
    def until(delim: Delimiter)(implicit oops: Oops): String = {
      skipWhite(myString)(myLimit, myDelim)
      val ans = rawParseToken(myString)(myLimit, delim)
      if (errorLevel > 1) OOPS
      if (inToken) errorLevel = 1
      if (error) OOPS
      ans
    }
    def until(delim: DelimByte)(implicit oops: Oops): String = {
      val d = new Delimiter{ def apply(c: Char) = ((c&0xFF00) == 0) && delim(c.toByte) }
      until(d)(oops)
    }
  }
  
  def text(s: Array[Byte]): GrokFullDelim = rawText(s, 0, s.length, DelimByte.whiteDelimByte)
  def text(s: Array[Byte], delim: DelimByte): GrokFullDelim = rawText(s, 0, s.length, delim)
  def text(s: Array[Byte], start: Int, limit: Int): GrokFullDelim = rawText(s, start, limit, DelimByte.whiteDelimByte)
  def text(s: Array[Byte], start: Int, limit: Int, delimiter: DelimByte): GrokFullDelim = rawText(s, start, limit, delimiter)
  def textSelfDelim(s: Array[Byte]): Grok = rawTextSelfDelim(s, 0, s.length, DelimByte.whiteDelimByte)
  def textSelfDelim(s: Array[Byte], delim: DelimByte): Grok = rawTextSelfDelim(s, 0, s.length, delim)
  def textSelfDelim(s: Array[Byte], start: Int, limit: Int): Grok = rawTextSelfDelim(s, start, limit, DelimByte.whiteDelimByte)
  def textSelfDelim(s: Array[Byte], start: Int, limit: Int, delimiter: DelimByte): Grok = rawTextSelfDelim(s, start, limit, delimiter)
  def rawText(s: Array[Byte], start: Int, limit: Int, delimiter: DelimByte): GrokText with GrokArrayTextControl with GrokFullDelim = 
    new GrokTextArrayTextControlImpl(s, start, limit, delimiter)
  def rawTextSelfDelim(s: Array[Byte], start: Int, limit: Int, delimiter: DelimByte): GrokText with GrokArrayTextControl with Grok =
    new GrokTextArrayTextControlImpl(s, start, limit, delimiter) { override def error = errorLevel > 1 }
  
  private class GrokTextArrayTextControlImpl(s: Array[Byte], start: Int, limit: Int, delimiter: DelimByte) extends GrokText with GrokArrayTextControl with GrokFullDelim {
    private[this] var myBytes = s
    private[this] var myZero = math.min(s.length, math.max(start, 0))
    private[this] var myLimit = math.min(s.length, math.max(myZero, limit))
    private[this] var myDelim = DelimByte.whiteDelimByte
    
    def bytes = myBytes
    def reset = indexTo(myZero).resume
    def resetWith(s: Array[Byte], start: Int, limit: Int) = {
      myBytes = s; myZero = math.min(s.length, math.max(0, start)); myLimit = math.min(s.length, math.max(myZero, limit))
      reset
    }
    def setDelimiter(delim: DelimByte) = { myDelim = delim; this }
    
    def inToken = index < myLimit && !myDelim(s(index))
    def hasNext = {
      val i = index
      (i < myLimit) && (!myDelim(s(i)) || {
        skipWhiteB(s)(myLimit, myDelim)
        index < myLimit
      })
    }
    def hasPrev: Boolean = {
      val i = index-1
      (i > myZero) && (!myDelim(s(i))) || {
        var j = i-1
        while (j > myZero) {
          if (!myDelim(s(j))) {
            indexTo(j+1)
            return true
          }
          j -= 1
        }
        indexTo(j+1)
        !myDelim(s(j-1))
      }
    }
    def skip(implicit oops: Oops) = if (hasNext) { skipBlackB(s)(myLimit, myDelim); this } else OOPS
    def back(implicit oops: Oops) = if (hasPrev) {
      var i = index-1
      while (i > myZero && !myDelim(s(i))) i -= 1
      indexTo(i)
      this
    } else OOPS
    
    def Z(implicit oops: Oops): Boolean = {
      skipWhiteB(myBytes)(myLimit, myDelim)
      val ans = rawParseTokenB(myBytes)(myLimit, myDelim)
      if (error) OOPS
      if (ans.length == 0) OOPS
      else {
        val b = ans(0) | 0x20
        if (b=='t') {
          if (ans.length == 1 || (ans.length == 4 && ((ans(1)|0x20)=='r') && ((ans(2)|0x20)=='u') && ((ans(3)|0x20)=='e'))) true
          else OOPS
        }
        else if (b=='y') {
          if (ans.length == 1 || (ans.length == 3 && ((ans(1)|0x20)=='e') && ((ans(2)|0x20)=='s'))) true
          else OOPS
        }
        else if (b=='n') {
          if (ans.length == 1 || (ans.length == 2 && ((ans(1)|0x20)=='o'))) true
          else OOPS
        }
        else if (b=='f') {
          if (ans.length == 1 || (ans.length == 5 && ((ans(1)|0x20)=='a') && ((ans(2)|0x20)=='l') && ((ans(3)|0x20)=='s') && ((ans(4)|0x20)=='e'))) true
          else OOPS
        }
        else OOPS
      }
    }
    def B(implicit oops: Oops): Byte = {
      skipWhiteB(myBytes)(myLimit, myDelim)
      val ans = rawParseLongB(myBytes, 10)(myLimit, myDelim)
      if (error || ans < -128 || ans > 255) OOPS
      (ans&0xFF).toByte
    }
    def S(implicit oops: Oops): Short = {
      skipWhiteB(myBytes)(myLimit, myDelim)
      val ans = rawParseLongB(myBytes, 10)(myLimit, myDelim)
      if (error || ans < Short.MinValue || ans > Short.MaxValue) OOPS
      (ans&0xFFFF).toShort
    }
    def C(implicit oops: Oops): Char = {
      val ans = rawParseCharB(myBytes)(myLimit)
      if (error) OOPS
      ans
    }
    def I(implicit oops: Oops): Int = {
      skipWhiteB(myBytes)(myLimit, myDelim)
      val ans = rawParseLongB(myBytes, 10)(myLimit, myDelim)
      if (error | ans < Int.MinValue || ans > Int.MaxValue) OOPS
      (ans&0xFFFFFFFFL).toInt
    }
    def L(implicit oops: Oops): Long = {
      skipWhiteB(myBytes)(myLimit, myDelim)
      val ans = rawParseLongB(myBytes, 10)(myLimit, myDelim)
      if (error) OOPS
      ans
    }
    def F(implicit oops: Oops): Float = {
      skipWhiteB(myBytes)(myLimit, myDelim)
      val ans = rawParseDoubleB(myBytes)(myLimit, myDelim)
      if (error) OOPS
      ans.toFloat
    }
    def D(implicit oops: Oops): Double = {
      skipWhiteB(myBytes)(myLimit, myDelim)
      val ans = rawParseDoubleB(myBytes)(myLimit, myDelim)
      if (error) OOPS
      ans
    }
    def tok(implicit oops: Oops): String = {
      skipWhiteB(myBytes)(myLimit, myDelim)
      val ans = rawParseTokenB(myBytes)(myLimit, myDelim)
      if (error) OOPS
      new String(ans)
    }
    def quoted(implicit oops: Oops): String = {
      skipWhiteB(myBytes)(myLimit, myDelim)
      val ans = rawParseStringB(myBytes)(myLimit)
      if (error) OOPS
      ans
    }
    def exact(target: String)(implicit oops: Oops) {
      skipWhiteB(myBytes)(myLimit, myDelim)
      rawParseExactB(myBytes, target)(myLimit, myDelim)
      if (error) OOPS
    }
    def select(targets: Array[String])(implicit oops: Oops): Int = {
      if (targets.length < 1) OOPS
      skipWhiteB(myBytes)(myLimit, myDelim)
      val j0 = index
      var i = -1
      do {
        i += 1
        indexTo(j0)
        rawParseExactB(myBytes, targets(i))(myLimit, myDelim)
      } while (error);
      if (error) OOPS
      i - 1
    }
    def until(delim: DelimByte)(implicit oops: Oops): String = {
      skipWhiteB(myBytes)(myLimit, myDelim)
      val ans = rawParseTokenB(myBytes)(myLimit, delim)
      if (errorLevel > 1) OOPS
      if (inToken) errorLevel = 1
      if (error) OOPS
      new String(ans)
    }
    def until(delim: Delimiter)(implicit oops: Oops): String = {
      val d = new DelimByte{ def apply(b: Byte) = delim((b&0xFF).toChar) }
      until(d)(oops)
    }
  }
  
  def apply(bs: Array[Byte]) = raw(bs, 0, bs.length)
  def apply(bs: Array[Byte], start: Int, limit: Int): Grok = raw(bs, start, limit)
  def raw(bs: Array[Byte], start: Int, limit: Int): GrokArrayBinaryControl with Grok = new GrokArrayBinaryControl with GrokFullDelim {
    private[this] var myBytes = bs
    private[this] var myZero = math.min(bs.length, math.max(0, start))
    private[this] var myLimit = math.max(myZero, math.min(bs.length, limit))
    private[this] var j = start
    private[this] var myEndian = java.nio.ByteOrder.LITTLE_ENDIAN == java.nio.ByteOrder.nativeOrder
    private[this] lazy val myGrok = new GrokText {
      def inToken = false
      def exact(target: String)(implicit oops: Oops) { ??? }
      def until(delim: kse.eio.DelimByte)(implicit oops: kse.flow.Oops): String = ???
      def until(delim: kse.eio.Delimiter)(implicit oops: kse.flow.Oops): String = ???
    }

    
    def bytes = myBytes
    def reset: this.type = { j = myZero; this }
    def resetWith(a: Array[Byte], start: Int, limit: Int) = {
      myBytes = a
      myZero = math.min(a.length, math.max(0, start))
      myLimit = math.max(myZero, math.min(a.length, limit))
      this
    }
    def bigEndian(big: Boolean): this.type = { myEndian = !big; this }
    def error = myGrok.error
    def index = j
    def indexTo(i: Int) = { j = math.max(myZero, math.min(i, myLimit)); this }
    def resume = this
    
    def inToken =  j < myLimit
    def hasNext(n: Int) = (j+n) <= myLimit
    def hasPrev(n: Int) = (j-n) >= myZero
    def hasNext = hasNext(1)
    def hasPrev = hasPrev(1)
    override def skip(n: Int)(implicit oops: Oops) = if (!hasNext(n)) OOPS else { j += n; this }
    def skip(implicit oops: Oops) = skip(1)(oops)
    override def drop(n: Int) = { j = math.max(myZero, j-n); this }
    override def back(n: Int)(implicit oops: Oops) = if (!hasPrev(n)) OOPS else { j -= n; this }
    def back(implicit oops: Oops) = back(1)(oops)
    override def undrop(n: Int) = { j = math.min(myLimit, j+n); this }
    
    def Z(implicit oops: Oops) = if (j >= myLimit) OOPS else { val ans = myBytes(j) != 0; j += 1; ans }
    def B(implicit oops: Oops) = if (j >= myLimit) OOPS else { val ans = myBytes(j); j += 1; ans }
    def S(implicit oops: Oops) = if (j+1 >= myLimit) OOPS else {
      val ans = if (myEndian) (myBytes(j)&0xFF) | ((myBytes(j+1)&0xFF)<<8) else ((myBytes(j)&0xFF)<<8) | (myBytes(j+1)&0xFF)
      j += 2
      ans.toShort
    }
    @inline def C(implicit oops: Oops) = S(oops).toChar
    def I(implicit oops: Oops) = if (j+3 >= myLimit) OOPS else {
      val ans =
        if (myEndian) (myBytes(j)&0xFF) | ((myBytes(j+1)&0xFF)<<8) | ((myBytes(j+2)&0xFF)<<16) | ((myBytes(j+3)&0xFF)<<24)
        else ((myBytes(j)&0xFF)<<24) | ((myBytes(j+1)&0xFF)<<16) | ((myBytes(j+2)&0xFF)<<8) | ((myBytes(j+3)&0xFF))
      j += 4
      ans
    }
    def L(implicit oops: Oops) = if (j+7 >= myLimit) OOPS else {
      val ans = 
        if (myEndian) (myBytes(j)&0xFFL) | ((myBytes(j+1)&0xFFL)<<8)  | ((myBytes(j+2)&0xFFL)<<16) | ((myBytes(j+3)&0xFFL)<<24) | 
              ((myBytes(j+4)&0xFFL)<<32) | ((myBytes(j+5)&0xFFL)<<40) | ((myBytes(j+6)&0xFFL)<<48) | ((myBytes(j+7)&0xFFL)<<56)
        else ((myBytes(j)&0xFFL)<<56) | ((myBytes(j+1)&0xFFL)<<48) | ((myBytes(j+2)&0xFFL)<<40) | ((myBytes(j+3)&0xFFL)<<32) | 
           ((myBytes(j+4)&0xFFL)<<24) | ((myBytes(j+5)&0xFFL)<<16) | ((myBytes(j+6)&0xFFL)<<8)  | ((myBytes(j+7)&0xFFL))
      j += 8
      ans
    }
    @inline def F(implicit oops: Oops) = java.lang.Float.intBitsToFloat(I(oops))
    @inline def D(implicit oops: Oops) = java.lang.Double.longBitsToDouble(L(oops))
    def tok(implicit oops: Oops) = {
      var k = j
      while (k < myLimit && myBytes(k) != 0) k += 1
      val ans = new String(myBytes, j, k)
      j = math.min(myLimit, k+1)
      ans
    }
    def quoted(implicit oops: Oops) = {
      val ans = myGrok.resume.indexTo(j).rawParseStringB(myBytes)(myLimit)
      if (myGrok.error) OOPS
      j = myGrok.index
      ans
    }
    override def getBs(a: Array[Byte], offset: Int, count: Int)(implicit oops: Oops): this.type = {
      val n = math.min(myLimit - j, count)
      java.lang.System.arraycopy(myBytes, j, a, offset, n)
      j += n
      if (n < count) OOPS
      this
    }
    def exact(target: String)(implicit oops: Oops) { ??? }
    def until(delim: kse.eio.DelimByte)(implicit oops: kse.flow.Oops): String = ???
    def until(delim: kse.eio.Delimiter)(implicit oops: kse.flow.Oops): String = ???
    def select(targets: Array[String])(implicit oops: kse.flow.Oops): Int = ???
  }
}

